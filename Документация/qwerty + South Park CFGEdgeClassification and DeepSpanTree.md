# Классификация ребер в графе потока управления данных + построение глубинного остовного дерева

(Граф управления потока управления данных: классификация ребер в графе потока управления данных, построение глубинного остовного дерева)

### qwerty, South Park

#### Постановка задачи

Задача состояла в реализации классификации ребер в графе потока управления данных и в реализации построения глубинного остовного дерева

#### Зависимости задач в графе задач
Данная задача зависит от задачи построения графа потока управления. Задача не порождает новых зависимостей.

#### Теория

В процессе классификации рёбер графа потока управления нужно определить, является ли ребро наступающим(advancing или forward), отступающим(retreating или back) или поперечным(cross). Ребро называется наступающим, если оно ведет от вершины-предка к вершине-потомку. Ребро называется отступающим, если оно ведет от вершины-потомка к вершине-предку. Ребро называется поперечным если ни одна из вершин не является предком другой.
Рёбра графа классифицируются при построении глубинного остовного дерева. Все рёбра дерева являются наступающими.

Остовное дерево – это дерево, содержащее все вершины графа и некоторые его дуги. Глубинное остовное дерево – это остовное дерево, полученное при обходе в глубину.
Данный обход начинается в вершине **v0** и заключается в последовательном включении вершин и ребер графа в дерево если их еще там нет. При этом следующий потомок вершины посещается лишь тогда, когда посещены все вершины достижимые из предыдущего потомка вершины. 

#### Особенности реализации

```csharp
public class SpanTree
{
    List<Edge> edges = new List<Edge>();
    List<Vertex> verts = new List<Vertex>();
    ControlFlowGraph cfg;
    int pre;

    public enum VertStatus
    {
        Init,
        InProcess,
        Done
    }

    public enum EdgeType
    {
        Tree,
        Back,
        Cross,
        Forward
    }
    public SpanTree(ControlFlowGraph CFG)
    {
        cfg = CFG;
        pre = 1;
    }
    public class Vertex
    {
        public int num;
        public int pre;
        public VertStatus status;

        public Vertex() { }
    }
    public class Edge
    {
        public Vertex v1;
        public Vertex v2;
        public EdgeType type;

        public Edge() { }
    }

    public void Traverse(Vertex v)
    {
        v.pre = pre++;
        v.status = VertStatus.InProcess;

        foreach (var e in edges)
        {
            if (e.v1.num == v.num)
            {
                var w = e.v2;
                switch (w.status)
                {
                    case VertStatus.Init:
                        e.type = EdgeType.Tree;
                        Traverse(w);
                        break;
                    case VertStatus.InProcess:
                        e.type = EdgeType.Back;
                        break;
                    case VertStatus.Done:
                        if (w.pre < v.pre)
                            e.type = EdgeType.Cross;
                        else e.type = EdgeType.Forward;
                        break;
                }
            }           
        }
        v.status = VertStatus.Done;
    }

    public List<Edge> buildSpanTree()
    {
        int[,] matr = cfg.cfg.GetAdjacencyMatrix();
        int[] vv = cfg.cfg.g;
        int m = cfg.cfg.n;

        //формирование списка вершин
        for (var i = 0;i< m;i++)
        {
            var vert = new SpanTree.Vertex();
            vert.num = i+1;
            vert.status = VertStatus.Init;

            verts.Add(vert);
        }

        //формирование списка рёбер
        foreach (var i in verts)
        {
            foreach (var j in verts)
            {
                if (matr[i.num-1, j.num-1] == 1)
                {
                    var ee = new Edge();
                    ee.v1 = i;
                    ee.v2 = j;
                    edges.Add(ee);
                }
            }
        }
        Traverse(verts[0]);
        return edges;
    }
}
```
Конструктор класса _SpanTree_ принимает в качестве аргумента граф потока управления программы (CFG), глобальной переменной ```pre``` присваивается начальное значение 1, это переменная для новой нумерации вершин. Реализованы классы для удобного представления вершин _```Vertex```_ и рёбер _```Edge```_, а также типы enum _```VertStatus```_ и _```EdgeStatus```_. Тип _```VertStatus```_ нужен для удобства определения статуса вершины: инициализированна (```Init```), в процессе рассмотрения (```InProcess```) и пройдена вместе со всеми своими потомками (```Done```). Тип _```EdgeStatus```_ нужен для определения вида ребра: ребро относится к глубинному остовному дереву (```Tree```), отступающее (```Back```), наступающее (```Forward```) и поперечное (```Cross```). 

Для получения списка всех рёбер с классификацией нужно вызвать метод _buildSpanTree_. В нем формируется список вершин и список рёбер, далее вызывается рекурсивный метод Traverse от первой варшины в графе. 

В методе _Traverse_ происходит обход в глубину графа потока управления, в процессе которого каждой вершине присваивается новый номер ```pre``` и происходит классификация рёбер графа. При рассмотрении каждой вершины рассматриваются все её потомки и определяется статус ребра следующим образом: если вершина-потомок только инициализирована, ребру присваивается статус ```Tree```; если вершина-потомок в процессе рассмотрения, ребру присваивается статус ```Back```; если вершина-потомок уже рассматривалась, то по ее номеру определяется, будет ли ребро поперечным или наступающим. Ребро наступающее (```Forward```) если новый номер pre вершины-потомка больше либо равно нового номера вершины-предка, иначе это ребро поперечное (```Cross```). В результате формируется список всех рёбер с классификацией. 

#### Тесты

Исходная программа:
```
{
	real b;
	int c;
	c=1;
	if (true)
	{
		b=3.14;
	} 
	int i;
	for (i=0 to 3)
	{
		c=c+1;
	}
        c = 0;
}
```
Полученный список рёбер:
```
v1=1, v2=2, type=Tree
v1=1, v2=3, type=Tree
v1=2, v2=4, type=Tree
v1=3, v2=4, type=Cross
v1=4, v2=5, type=Tree
v1=5, v2=6, type=Tree
v1=5, v2=7, type=Tree
v1=6, v2=8, type=Tree
v1=7, v2=5, type=Back
```

