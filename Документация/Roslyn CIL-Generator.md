### Генерация CIL-кода по трехадресному программному коду.
Генерация CIL-кода программы, приближенному к машинному коду, с возможностью исполнения по трехадресному коду.

### Команда Roslyn

#### Постановка задачи
Требуется произвести преобразование трехадресного кода программы в формат CIL-кода с возможностью исполнения полученной бинарной программы.


#### Зависимости задач в графе задач

Задача зависит от:
* генерации трехадресного кода.

#### Теория
Одна из основных целей реализации нового языка программирования - это предоставление возможности исполнения программ, написанных на реализованном языке программирования. В рамках текущего курса в качестве среды исполнения программного коды был выбран DotNet Framework, в который встроены средства генерации бинарных исполняемых файлов Reflection Emit на языке CIL. Воспользовавшись данным генератом, можно создавать исполняемые файлы среды DotNet Framework и производить их запуск.

#### Особенности реализации
В реализованном генераторе IL-кода происходит два этапа генерации:
1) инициализация переменных и меток;
2) генерация основного кода.

На первом этапе генератор производит анализ всего трехадресного кода, для которого требуется сгенерировать IL-код, выискивая в нем метки кода и переменные. Для всех найденных меток происходит инициализация объекта типа System.Reflection.Emit.Label, который в дальнейшем будет сопоставлен с текущей меткой трехадресного кода. При обнаружении переменной, которая не встречалась ранее по программному коду, происходит вывод ее типа по значению константных значений и переменных, участвующих в выражении справа от присваивания. При этом следует учесть, что использование неинициализированных переменных внутри арифметического выражения является недопустимым. В случае, если вывести тип переменной не удается, то происходит ошибка компиляции. При успешном определении типа переменной происходит инициализация объекта типа LocalBuilder.

После успешной инициализации вспомогательной информации, меток и переменных происходит этап генерации основного CIL-кода. Для этого происходит повторное рассмотрение всех команд трехадресного кода и конвертирование их в команды CIL-кода, используя преобразования, позволяющие получить эквивалентный код.

Для генерации CIL-кода следует выполнить следующие шаги:
1) создать объект типа SimpleLang.Compiler.ILCodeGenerator;

2) Подать методу Generate созданного объекта исходный трехадресный код.

После успешной генерации CIL-кода можно произвести запуск сгенерированной программы, вызвав метод Execute, которые возвращает строку, которую выведет на консоль сгенерированная программа. Таким образом, последовательность команд, позволяющих запустить сгенерированный трехадресный код представлен ниже.

``` charp
SimpleLang.Compiler.ILCodeGenerator gen = new SimpleLang.Compiler.ILCodeGenerator();
gen.Generate(threeCode);
string res = gen.Execute();
```
В данном коде подразумевается, что переменная *threeCode* хранит трехадресный код программы.

#### Тесты
Исходный код программы
``` charp
{
	bool w;
	w = (1 < 2) && (3 < 5);

	int a;
	int b;
	int c;

	a = 0;
	b = 1;

	while (w) {
		c = a;		
		a = b;
		b = c + a;
		println(a);
		
		w = (a < 1000000);
	}
}
```

Генератор трехадресного кода вернет следующий код:
``` charp
    temp_1 = 1 < 2
    temp_2 = 3 < 5
    temp_0 = temp_1 && temp_2
    w = temp_0
    a = 0
    b = 1

label_0:   temp_3 = w
    if temp_3 goto label_1

    goto label_2

label_1:   c = a
    a = b
    b = c + a
    println a
    w = a < 1000000
    goto label_0

label_2:   
```

После генерации CIL-кода получается следующий код:
``` charp
DeclareLocal var0: System.Boolean
DeclareLocal var1: System.Int32
DeclareLocal var2: System.Int32
DeclareLocal var3: System.Int32
DeclareLocal var4: System.Boolean
DeclareLocal var5: System.Boolean
DeclareLocal var6: System.Boolean
DefineLabel Label0
DeclareLocal var7: System.Boolean
DefineLabel Label1
DefineLabel Label2
ldc.i4 1
ldc.i4 2
clt
stloc var4
ldc.i4 3
ldc.i4 5
clt
stloc var5
ldloc var4
ldloc var5
and
stloc var6
ldloc var6
stloc var0
ldc.i4 0
stloc var1
ldc.i4 1
stloc var2
MarkLabel Label0
ldloc var0
stloc var7
ldloc var7
brtrue.s Label1
br Label2
MarkLabel Label1
ldloc var1
stloc var3
ldloc var2
stloc var1
ldloc var3
ldloc var1
add
stloc var2
ldloc var1
WriteLine
ldloc var1
ldc.i4 1000000
clt
stloc var0
br Label0
MarkLabel Label2
```
Результатом выполнения программы будет следующий текст:
``` charp
1
1
2
3
5
8
13
21
34
55
89
144
233
377
610
987
1597
2584
4181
6765
10946
17711
28657
46368
75025
121393
196418
317811
514229
832040
1346269
```