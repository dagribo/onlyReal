### Оптимизация умножения на 0 в AST-дереве
Оптимизация AST-дерева. Оптимизация алгебраических выражений, в которых происходит умножение на 0.

### Команда Roslyn

#### Постановка задачи
Требуется найти в AST-дереве выражения, в которых происходит умножение некоторого подвыражения на константное число 0 и произвести замену всего выражения на число 0.

#### Зависимости задач в графе задач
Задача зависит от:
* генерация AST-дерева;
* заполнение связей типа "предок-потомок".

#### Теория
В исходном коде программы в некоторых случаях можно встретить явное умножение алгебраического выражения на число 0. В данному случае можно произвести оптимизацию кода на этапе компиляции, заменив все подвыражение на константное значение 0. К случаям, когда можно применить оптимизацию, можно отнести следующие:
* *b\*0*
* *0\*b*

Подобные выражения можно оптимизировать, если при компиляции исходного кода программы заменить данное выражение на число 0. Подобная оптимизация позволит сделать вычисление программы более быстрым, поскольку потребуется меньше памяти для вычисления программы, поскольку некоторые переменные перестанут быть необходимыми, и операций работы с оперативной памятью.

#### Особенности реализации
При использовании программного кода, позволяющего произвести оптимизацию выражений, внутри которых происходит умножение на 0, требуется произвести построение AST-дерева для исходного кода программы, написанном на реализованном языке программирования, и выделить для построенного дерева связи типа "предок-потомок". К полученному дереву следует применить визитор SimpleLang.Visitors.Opt2Visitor. Таким образом, последовательность действий для использования данной оптимизации будет следующей:
1) сгенерировать AST-дерево;
2) с помощью визитора SimpleLang.Visitors.FillParentVisitor заполнить связи между узлами дерева типа "предок-потомок";
3) создать объект типа SimpleLang.Visitors.Opt2Visitor;
4) для полученного дерева вызвать функцию Visit с объектом Opt2Visitor, созданном на 3-ем этапе, поданным как аргумент функции.
```csharp
using SimpleLang.Visitors;
...
FillParentVisitor pvisit = new FillParentVisitor();
tree.Visit(pvisit);
Opt2Visitor zvisit = new Opt2Visitor();
tree.Visit(zvisit);
```
В данном коде подразумевается, что переменная *tree* содержит в себе AST-дерево программы.


#### Тесты
Для исходного кода 
```csharp
{
	int b;
	b = b * (1+2+3+123+321) * (654/332*0) + 123;
}
```

После использования оптимизации умножения на 0 в AST-дереве получается следующий код:
```csharp
{
	int b;
	b = b * (1+2+3+123+321) * (0) + 123;
}
```
Если использовать данную оптимизацию каскадно, то можно получить следующий код:
```csharp
{
	int b;
	b = 0 + 123;
}
```
