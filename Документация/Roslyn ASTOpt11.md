### Оптимизация условного оператора, в условии которого стоит константа, принимающая истинное значение в AST-дереве
Оптимизация AST-дерева. Оптимизация условных операторов, в условии которых используется константное значение, принимающее истинное значение.

### Команда Roslyn

#### Постановка задачи
Требуется найти в AST-дереве условные операторы, в условии которых используется константное значение, принимающее истинное значение, и произвести замену всего условного оператора в AST-дереве на операторы из ветки true данного оператора.

#### Зависимости задач в графе задач
Задача зависит от:
* генерация AST-дерева;
* заполнение связей типа "предок-потомок".

#### Теория
В исходном коде программы в некоторых случаях можно встретить условный оператор, в котором в явном виде в условии указано константа true. В данному случае можно произвести оптимизацию кода на этапе компиляции, заменив весь условный оператор на операторы из его ветки по условию истинности. К случаям, когда можно применить оптимизацию, можно отнести следующие:
* *if ( true ) { OperatorTrue; } else { OperatorElse; }*

Подобные условные операторы можно оптимизировать на этапе компиляции, заменив весь код данного условного оператора на операторы ветки true. В данном примере это *{ OperatorTrue; }*. Данная оптимизация позволит избавить код программы от лишних вычислений условного оператора, а также от ненужных операторов перехода, которые могут замедлить выполнение скомпилированной программы.

#### Особенности реализации
При использовании программного кода, позволяющего произвести оптимизацию условного оператора, принимающего в качестве условия истинную константу, требуется произвести построение AST-дерева для исходного кода программы, написанном на реализованном языке программирования, и выделить для построенного дерева связи типа "предок-потомок". К полученному дереву следует применить визитор SimpleLang.Visitors.Opt11Visitor. Таким образом, последовательность действий для использования данной оптимизации будет следующей:
1) сгенерировать AST-дерево;
2) с помощью визитора SimpleLang.Visitors.FillParentVisitor заполнить связи между узлами дерева типа "предок-потомок";
3) создать объект типа SimpleLang.Visitors.Opt11Visitor;
4) для полученного дерева вызвать функцию Visit с объектом Opt11Visitor, созданном на 3-ем этапе, поданным как аргумент функции.
```csharp
using SimpleLang.Visitors;
...
FillParentVisitor pvisit = new FillParentVisitor();
tree.Visit(pvisit);
Opt11Visitor zvisit = new Opt11Visior();
tree.Visit(zvisit);
```
В данном коде подразумевается, что переменная *tree* содержит в себе AST-дерево программы.


#### Тесты
Для исходного кода 
```csharp
{
	int b;
	int a;
	a = 0;
	b = 1;
	if ( true ) {
	    int r;
	    r = a;
	    a = b;
	    b = r + a;
	} else {
	    int i;
	    for (i=1 to 100)
	        a = b * i;
	}
	println(a);
}
```

После использования оптимизации условного оператора, принимающего в качестве условия истинное значение, в AST-дереве получается следующий код:
```csharp
{
	int b;
	int a;
	a = 0;
	b = 1;
	{
	    int r;
	    r = a;
	    a = b;
	    b = r + a;
	}
	println(a);
}
```
